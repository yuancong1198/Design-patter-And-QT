#pragma once

/*
简单工厂模式、工厂模式、抽象工厂模式异同：
简单工厂模式：
	定义：	把一系列拥有共同特征的产品的封装起来，通过一个工厂类创建统一类型的接口，而避免new操作。
	使用场景：	简单工厂模式一般应用于多种同类型类的情况，将这些类隐藏起来，再提供统一的接口，便于维护和修改。
	优点：
		1.隐藏了对象创建的细节，将产品的实例化推迟到子类中实现。

		2.客户端基本不用关心使用的是哪个产品，只需要知道用哪个工厂就行了，提供的类型也可以用比较便于识别的字符串。

		3.方便添加新的产品子类，每次只需要修改工厂类传递的类型值就行了。

		4.遵循了依赖倒转原则。
	缺点：
		1.要求产品子类的类型差不多，使用的方法名都相同，如果类比较多，而所有的类又必须要添加一种方法，则会是非常麻烦的事情。
			或者是一种类另一种类有几种方法不相同，客户端无法知道是哪一个产品子类，也就无法调用这几个不相同的方法。

		2.每添加一个产品子类，都必须在工厂类中添加一个判断分支，这违背了开放-封闭原则。
工厂模式：
	定义：由于简单工厂模式每次添加一个产品子类都必须在工厂类中添加一个判断分支，这样违背了开放-封闭原则，而工厂模式为解决此类产生。
	使用场景：基本与简单工厂模式一致，只不过是改进了简单工厂模式中的开放-封闭原则的缺陷，使得模式更具有弹性。将实例化的过程推迟到子类中，由子类来决定实例化哪个。
	优点：基本与简单工厂模式一致，多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强。
	缺点：与简单工厂模式差不多。

抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
	使用场景：例如Linux和windows两种操作系统下，有2个挂件A和B，他们在Linux和Windows下面的实现方式不同，Factory1负责产生能在Linux下运行的挂件A和B，Factory2负责产生能在Windows下运行的挂件A和B，这样如果系统环境发生变化了，我们只需要修改工厂就行了。
	优点：
		1.封装了产品的创建，使得不需要知道具体是哪种产品，只需要知道是哪个工厂就行了。

		2.可以支持不同类型的产品，使得模式灵活性更强。

		3.可以非常方便的使用一族中间的不同类型的产品。
	缺点：
		1.结构太过臃肿，如果产品类型比较多，或者产品族类比较多，就会非常难于管理。

		2.每次如果添加一组产品，那么所有的工厂类都必须添加一个方法，这样违背了开放-封闭原则。所以一般适用于产品组合产品族变化不大的情况。
	
	
	
	*/