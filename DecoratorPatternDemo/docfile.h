#pragma once

/*
一、引言
		（1）第一种说法
		时常会遇到这样一种情况，我已经设计好了一个接口，并且也有几个实现类，但是这时我发现我设计的时候疏忽了，忘记了一些功能，
	或者后来需求变动要求加入一些功能，最简单的做法就是修改接口，添加函数，然后继承类中都相应的添加实现，这样做倒也没什么问题，
	但是如果这种变化来个好几次或者继承类非常多，那工作量可就大了。
		这时大神们就发明了装饰者模式，在不修改现在有接口和实现类的基础上实现功能或者状态的添加。
		（2）第二种说法
		装饰者模式是很有意思的一种设计模式，你将能够在不修改任何底层代码的情况下，给你的（或别人的）对象赋予新的职责。
	不是使用继承每回在编译时超类上修改代码，而是利用组合（composition）和委托（delegation）可以在运行时具有继承行为的效果。
		代码应该如同晚霞中的莲花一样地关闭（免于改变），如同晨曦中的莲花一样地开放（能够扩展）。
	这就是，设计原则之五：类应该对扩展开放，对修改关闭。
二、定义
	装饰者模式（Decorator)：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成子类更灵活。

三、常用的情况
		如果需要添加新功能，但又不想修改定义好的接口或者抽象类，那么这时候就比较适合装饰模式，例如很多图形系统中的组件，就可以使用装饰模式，
	来让新的组件在继承现在功能的基础上添加新的功能。
	装饰模式一般是针对接口或者抽象类的变化，如果是具体实现类的变化，则要考虑适用哪种模式。

四、优点
	1.可以不用修改原有的接口，就可以实现新功能的添加。

	2.装饰者可以很方便的转换原有接口中的实现，可以给装饰者指定不同的ConcreteComponent实现不同的功能。

五、缺点
	1.复杂性增加，装饰者模式会导致许多小类的产生。

六、装饰者模式和继承的区别
	继承实现的增强类：
	　　	优点：代码结构清晰，而且实现简单
		  　缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。


	装饰模式实现的增强类：
			优点：内部可以通过多态技术对多个需要增强的类进行增强
			缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。
*/