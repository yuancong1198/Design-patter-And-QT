#pragma once

/*
① 《单例模式（Singleton）》：保证一个类仅有一个实例，并提供一个访问它的全局访问点。(该实例被所有程序模块共享。)

方式：根据单例对象创建时间可分为饿汉模式和懒汉模式
（一)饿汉模式
		定义：在调用之前实例已被初始化。因为main函数执行之前，全局作用域的类成员静态变量m_Instance已经初始化，故没有多线程的问题。
		优点：实现简单，多线程安全。
		缺点：
		（1）如果存在多个单例对象且这几个单例对象相互依赖，可能会出现程序崩溃的危险。

		（2）在程序开始时，就创建类的实例，如果Singleton对象产生很昂贵，而本身有很少使用，这种方式单从资源利用效率的角度来讲，比懒汉式单例类稍差些。

		但从反应时间角度来讲，则比懒汉式单例类稍好些。

		使用条件：
		（1）当肯定不会有构造和析构依赖关系的情况。

		（2）想避免频繁加锁时的性能消耗。

		相关解释：
		（1）多线程下安全：由于类的实例是在类创建的同时就已经创建好，以供系统使用。多个线程线程对该实例的访问是在创建之后，所以安全。

		（2）在多个单例对象相互依赖时，程序可能崩溃：对编译器来说，静态成员变量的初始化顺序和析构顺序是一个未定义的行为，也就是对于多个静态对象，
		
		先调用哪一个静态对象的构造函数，后调用哪个静态对象的构造函数，编译器也没个准。对应的，静态对象的析构函数的调用顺序也是不定的
		
		(析构函数的调用顺序与构造函数的调用顺序相反，但是因为静态对象的构造函数的调用顺序是不确定的，所以说静态对象的析构函数的调用顺序也是不确定
		
		的)。所以，若单例实例a的初始化用到单例实例b的值，而实例b有可能在实例a之后初始化，此时程序会引用一个未初始化的内存而出现异常。

		说明：

		（1）也可以使用静态指针 + 类外初始化时new空间实现。

		（2）对于静态变量，需要在类外或者说是Cpp文件中进行定义，分配空间，这个容易忘。
（二）饿汉模式

		定义：指全局的单例实例在第一次被使用时构建。

		注意：由于局部静态变量instance是在第一次使用时才被创建，因此它不是线程安全的。

		实现方式有两种：静态指针 + 用到时初始化 和 局部静态变量


②《MONOSTATE模式》

	Monostate是另一种获取对象单一性的方法。它的原理很简单，就是一个Monostate的所有对象共享相同的变量。
要做到这一点只要把所有的变量都变成静态变量即可。

	Monostate模式的优点：

	1.     透明性          用户不必知道使用的对象是Monostate。

	2.     可派生性        构造子是公有的，所以可以派生。它的所有派生类都共享相同的静态变量。

	3.     多态性          由于Monostate的方法不是静态的，所以可以在派生类中覆写它们，因此，不同的派生类可以基于同样的静态变量表现出不同的行为。

	Monostate模式的缺点:

	1. 不可转换性：       不能透过派生把常规类转换成Monostate。

	2. 效率问题：         因为Monostate是真正的对象，所以会导致许多的创建和摧毁的开销

	3. 内存占用：         即使从未使用Monostate,它的变量也要占据内存空间。

	4.平台局限性：        Monostate不能跨越多个平台。


③ 模式讨论
    Monostate模式和Singleton模式都能够获得“系统某个类别对象都表现的像只有一个对象”，Singleton模式重在通过保证系统中只有唯一实例，

而Monostate模式重在保证唯一状态（当然Singleton模式更多的是用来保证唯一实例）。Monostate模式更多关注的是行为，即行为上的一致；

Singleton模式更多关注的是结构，强制结构上的单一，仅产生唯一实例。

*/